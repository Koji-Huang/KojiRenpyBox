# 小白都能看懂的 Renpy CDD 教程 ( 视频稿子 )

---

## Stage 1 可视化组件相关概念

>   fix:
>
>   重新录制打字画面
>
>   重新录制声音
>
>   screen 名更改为 screen stage1_add

### opening

>   ( 显示标题 )
>
>   本期视频里, 我会着重于介绍可视化组件的相关概念, 在下期视频里才讲述该如何编写 CDD
>
>   如果你足够了解 Renpy 的可视化组件系统, 可以直接去看下个视频

### a. 什么是可视化组件?

>   ( 显示标题 )
>
>   ( 显示可视化组件页面 )
>
>   首先 什么是可视化组件呢？
>
>   我认为, 可视化组件就是将画面表达出来, 提供用户交互的组件
>
>   例如你现在看到的视频 里面有标题栏 有进度条 有全屏按钮
>
>   这些东西都是所谓的可视化组件 

>   ( 显示 rpy 文件 screen )
>
>   在 Renpy 里面, 我们都知道编写交互界面使用的是 screen 语句
>
>   ( 显示打了 tip 的 rpy 文件 screen )
>
>   Renpy 预设了不少的可视化组件与相应的语法供 screen 语句使用

>   ( B站搜索 CSS 动画)
>
>   然而, 系统提供的可视化组件在一定程度上对于想实现华丽效果的开发者来说是不够用的
>
>   这个时候就需要自定义可视化组件技术了
>
>   自定义可视化组件可以让你自己编写组件的渲染, 交互逻辑. 
>
>   也就是能以最大程度的自由来定义你的每一个组件
>

### b. 系统的可视化组件

>   ( 显示小标题 )
>
>   ( 显示文档界面 https://doc.renpy.cn/zh-CN/displayables.html#image-like-displayables )
>
>   在 Renpy 的文档里我们可以直接查到大量的可视化组件
>
>   然而 有些组件 Renpy 并没有明确的写明在文档里

>   ( 显示 button 搜索结果 )
>
>   例如 我们在 screen 里面使用的 button
>
>   我们只可以查到他在 Renpy 语法下的词条, 它的可视化组件在文档里面是找不到的
>
>   这个时候, 我们就需要自己去看 Renpy 引擎里面组件的源码
>
>   这些源码不仅可以直接调用, 还可以参考学习是很有价值的一手资料
>
>   这里我列举三个我参考组件源码时最常用的文件

>   `renpy/display/displayable.py`
>
>   这个文件里面编写了 Displayable 类
>
>   这个类是所有可视化组件的根类
>
>   里面定义了可视化组件的基础框架和接口
>
>   我们可以查看源码里的注释来理解它对各项接口的解释与说明

>   `renpy/display/behavior.py`
>
>   在这个文件里定义了大量的界面交互组件
>
>   例如: Bar 组件 Button 组件 Timer 组件 Input 组件
>
>   我们既可以以这里面实现的可视化组件为父对象拓展他们的功能
>
>   也可以以他们为参照编写新的实现方式

>   `renpy/display/layout.py`
>
>   这个文件里定义了大量的布局组件
>
>   例如: Container, Null, Fixed, Crop
>
>   其中, Container 是容器组件的根类
>
>   如果你希望编写一个新的容器组件, 你应该以 Container 为参照编写

### c. 如何显示一个可视化组件

>   ( 显示小标题 )
>
>   ( 显示 VSCode 界面 )
>
>   如何显示一个可视化组件?
>
>   最简单的办法是使用 add 语句
>
>   add 语句在界面上添加一个图像或者其他的可视化组件
>
>   添加时可以选择使用 Transform 特性列表

>   ( 开一个空白工程 )
>
>   那么, 现在我们来试验一下, 打开一个空白的工程
>
>   我们可以看到, 这里是程序的主界面
>
>   我们现在希望往主界面上添加一个文本组件, 上面写着"你好世界"
>
>   现在, 我们就需要使用 Text 可视化组件, 然后用 add 语句将他添加上去

>   现在运行代码
>
>   此时我们可以看见 “你好世界” 已经被添加到屏幕上来了
>
>   此外, 我们可以传入一些 transform 特性来改变组件的位置
>
>   **比如, 我们给这个 add 语句后面加上 xalign 0.5, 让他在布局里居中**
>
>   **刷新界面, 我们可以看到文字在屏幕里居中了**

### d. add 语句的本质是?

>   观察这段代码, 我们可以发现这行语句是由
>
>   add + 实例化可视化组件 + transform 特性组成的
>
>   那么, 可不可以让 add 语句直接添加一个提前实例化好的可视化组件呢
>
>   让我们稍微改变一下代码的结构
>
>   先在外面定义了一个叫做 hello_world 的变量
>
>   这个变量存储着一个 Text 可视化组件
>
>   让我们直接把这个组件 add 到屏幕上来
>
>   **刷新界面**
>
>   我们可以看到这个组件依然被正确的添加到上面

>   那么, 这个 add 上来是组件和 hello_world 变量的组件是同一个吗?
>
>   验证这点的话, 我们可以先用 for 语句一次性添加多个 hello_world
>
>   然后将 Text 组件换成可以响应鼠标事件的 TextButton 组件
>
>   填好参数后, 让我们看看运行的效果

>   **我们可以看到, 一个按钮被遮盖的时候, 其他按钮也会显示出被遮盖的效果**
>
>   那么我们可以认为:
>
>   add 语句本质上就是将已经初始化好的可视化组件引用到屏幕上的语句
>
>   也就是这些 "你好世界" 全部都是引用着同一个可视化组件
>
>   都是 hello_world 储存的那个可视化组件
>
>   所以无论哪一个 add 触发了遮盖, 都会触发源组件的更新
>
>   从而导致所有的引用被更新
>
>   总结起来就是: add 语句本质上就是一个可以利用 transform 特性的对其他组件的引用语句

### ending?

>   以上就是可视化组件的相关概念
>
>   下期视频将会介绍如何编写一个简单的可视化组件
>
>   那么下期视频, 再见

---

## Stage 2: 自定义显示一个图片并添加简易效果

### opening

>   ( 打开 VSCode )
>
>   在上期视频里, 我介绍了什么是可视化组件, 与之相关的定义和调用, 本期将介绍该如何编写一个简易的可视化组件, 也就是介绍可视化组件的 render 函数

### a. 如何定义一个可视化组件

>   (显示子标题)
>
>   (显示 Renpy 程序与 VSCode)
>
>   首先, 我们定义一个自定义的可视化组件时必须包含两个条件:
>
>   1.   所有的可视化组件必须主动或间接继承自 `renpy.display.displayable.Displayable` 类, 调用上我们可以直接写成 `renpy.Displayable`
>   2.   所有的可视化组件必须有 render 函数
>
>   我们这里举个例子, 首先我们先随便写一个类并尝试直接显示到屏幕上 ( 随便瞎写, 总之不要先继承自 `renpy.Displayable` )
>
>   我们可以清晰的看到程序爆了错, 这是因为我们并没有正确的继承 `renpy.Displayable`, 现在让我们正确的继承一下 `renpy.Displayable` ( 总之不要先写 render 函数 )
>
>   我们可以看到程序又爆了错, 然而这次的报错和上次不同, 这次的报错是因为这个类并没有定义 render 函数, 怎么编写 render 函数的内容我们后面再说, 总之我们这里先随便写点东西让 render 函数返回一个合理的值先, 
>
>   这个时候我们可以看到这个组件被正确的显示出来了, 总结一下: 所有的可视化组件----以及-----

### b. render 函数的相关解析

>   这里我引用一下 `renpy.displayable.display` 中 `Displayable.render` 函数的代码注释
>
>   ```python
>   def render(self, width, height, st, at):
>       """
>       Called to display this displayable. This is called with width
>       and height parameters, which give the largest width and height     
>       that this drawable can be drawn to without overflowing some
>       bounding box. It's also given two times. It returns a Surface
>       that is the current image of this drawable.
>   
>   	调用以显示此可视化组件。
>   	被调用时会传入宽度和高度参数，它们给出了这个可视化组件可以绘制到的最大宽度和高度，而不会溢出一些边界框。
>   	也会传入两个时间戳
>   	它会返回一个Surface对象, 即此可视化组件的当前图像。
>   
>       @param st: The time since this widget was first shown, in seconds.
>       @param at: The time since a similarly named widget was first shown,
>       in seconds.
>   
>       @参数 st: 以秒为单位, 此可视化组件第一次被显示时的时间戳
>       @参数 at: 以秒为单位, 一个相同名称的可视化组件被第一次显示时的时间戳
>       """
>   ```
>
>   然后我说说我对这些参数的理解吧:
>
>   `width, height`:
>
>   >   `width, height` 为此可视化组件在布局中被分配的大小, 此参数会随着一些布局以及参数发生变化, 但这不代表我们只能在 `width, height` 的范围内绘制图像, 我们可以超出或小于这个范围绘制, 这个值仅仅是一个指导值, 方便于适应界面的布局方式.
>
>   `st, at`:
>
>   >    正如注释里说的, `st, at`  是表达组件被显示的时间的两个参数, 理解这两个参数的不同需要一个小小的例子来展示
>   >
>   >    (显示代码和程序)
>   >
>   >    这里我们写了一个简单的可视化组件来显示这个组件的 st, at, 然后让我们将这个组件显示出来
>
>   >    ```python
>   >    image a = A_Displayable() # 注意这里的 A_Displayable 指的是任意一个可视化组件, 本身没有这个类型
>   >    
>   >    label start:
>   >       show a
>   >       "现在 st 和 at 都从 0 开始计数"
>   >       show a
>   >       "现在 st 被重置为 0 了 (此可视化组件第一次被显示时的时间戳)\n但 at 仍然是之前的计数 (一个相同名称的可视化组件被第一次显示时的时间戳)"
>   >       hide a
>   >       "...."
>   >       show a
>   >       "现在 st 和 at 都从 0 开始计数"
>   >    ```
>   >
>   >    现在我相信你已经理解了这两个参数的不同, 顺带一提, 在写 screen 时一般我们都不需要考虑 at 的值
>   >
>
>   `render` 函数的返回值:
>
>   >   `render` 函数必须返回一个 `Render` 对象, `Render` 对象是储存并传递此可视化组件画面的对象, 你可以把它理解为绘画工具里面的一个图层, 我们需要把这个组件的画面丢在这个图层里面, 把它传递给引擎绘制出来, 很好理解吧?
>
>   >   我们可以通过 `renpy.Render(w, h)`来获取一个透明的 `Render` 对象,  `w, h` 为此对象应该占据的宽高 ( 但实际上和很多绘图软件的图层一样, 我们绘制的范围是可以超出此这个限制的, 这两个参数另有他用 )
>   >
>   >   (  https://doc.renpy.cn/zh-CN/cdd.html#renpy.Render 贴出文档 )
>   >
>   >   Render 对象在文档中也有对应的描述, 对这个对象感兴趣的话可以自行查询文档

### c. 显示一张图片

>   我们上面说过, Render 对象就像一个图层,  我们需要把这个组件的画面丢在这个图层里面, 把它传递给引擎绘制出来. 所以我们可以调用其他可视化组件的 render 函数, 获取他们绘制的 Render 对象并覆盖到这个组件的 Render 上.
>
>   ( 贴出代码 )
>
>   这里我们使用 `renpy.displayable()` 函数获取了一个渲染图片的可视化组件--- Image 对象, 然后在 render 函数里直接返回这个 Render 对象作为这个组件的画面, 这样---我们就成功显示了一张图片

### d. 显示一张图片并进行移动

>   Render 对象有一个 blit 函数, 这个函数的作用是将其他 Render 对象上面的画面覆盖到此 Render 函数上, 让我们看看文档:
>
>   (文档内容 https://doc.renpy.cn/zh-CN/cdd.html#renpy.Render.blit, 等待10秒左右 )
>
>   此时我们就可以编写一段简单的代码让图片做圆形的运动
>
>   ( 贴出代码, 讲解 )
>
>   那么让我们运行看看
>
>   ( 然后图片卡住了 )
>
>   图片卡住了? 实际上, renpy 默认会在以很低的频率更新可视化组件, 也就是说, 在我们不主动请求下, Renpy 是不会更新我们的组件的, 这个时候我们就需要用到另一个函数来向 Renpy 请求更新此组件----renpy.redraw 
>
>   (文档内容: https://doc.renpy.cn/zh-CN/cdd.html#renpy.redraw 等待10秒左右 )
>
>   那么我们现在将这个函数加入到我们的 render 函数里, 让他每次渲染完成后都申请立即重新绘制

### ending?

>   看完本节, 你应该已经学会了该如何让自己的可视化组件显示出自己想要的图像了, 下节教程里我将介绍该如何编写组件与用户的交互

---

##  Stage 3: 响应用户交互的组件

>   在上文里我们已经讲过了要怎么让可视化输出画面 ,在这里, 我们讲一下要怎么让可视化组件与用户进行交互, 也就是 `CDD` 的 `event` 函数

### a. 什么是 event 函数

>   `event` 函数是用于处理可视化组件事件的函数, 当存在新的事件时会调用这个函数来接收并处理对应的事件, 首先引用一下 `renpy.display.displayable.py` 里 `event` 函数的代码注释
>
>   ( 贴出代码 )
>
>   在这个教程里, 我先不讲 `event` 函数的返回值具有什么意义, 而是重点聚焦在前面的第一个参数 `ev`, 此参数是一个存储了交互信息的参数, 通过解析这个参数我们就可以解析用户进行了哪些行为
>
>   首先, ev 参数有一个 type 参数来判断事件, 这个参数的值为 int, 这些值是以 pygame 的 event  为基础定义的, `Pygame` 里存在一些常量用于确认对应的类型, 比如 `pygame.MOUSEBUTTONDOWN = 1025`
>
>   所以当我们需要判断一个 `ev` 为某个事件时, 就可以用 `ev.type == pygame.xxx(某个常量)` 来判断当前 `ev` 是否为某个事件, 比如 `ev.type == pygame.MOUSEBUTTONDOWN`就是判断当前事件是否为鼠标按下事件
>
>   ( 贴出代码并运行 )
>
>   而这些事件对应的各个常量命名都各自有自己的规则, 这里贴出 pygame 里面对各个事件产量的命名:
>
>   ( 开网站 )
>
>   此外, renpy 也有自己的事件检测方式: renpy.map_event, 这个函数比起 pygame 里面声明的产量之外还可以检测出 Renpy 自定义的一些 event, 相关介绍也有文档 ( 贴图 ), 假如你希望你的组件相应这些交互事件, 那可以考虑用这个来代替 pygame 的那套
>
>   然后, `ev` 中包含有次事件对应的参数, 这个不难理解, 我们可以用 `ev.__dict__` 把 `ev` 的属性打印出来, 就比如 `MOUSEBUTTONDOWN` 事件:
>
>   ( 贴出代码和运行输出 )
>
>   在这里我们可以通过 `button` 参数来获取此 `MOUSEBUTTONDOWN` 事件中鼠标按下的按钮为哪一个
>
>   注意, 不同的 `ev` 甚至是同个 `type` 的 `ev` 都会有不一样的属性 (例如滚轮滑动, 它的 `type` 也是 `MOUSEBUTTONDOWN`, 但参数却有所不同), 所以在使用 ev 参数的时候还请多多注意

### b. 实现相应用户点击

>   那么, 在了解完上面的概念后, 我们就可以很轻松的编写出一个响应用户鼠标事件的组件了
>
>   (贴出代码和 VS Code)
>
>   这里我定义了一个组件, 这个组件会在鼠标按下时立即切换图片, 让我们看看运行结果吧

### c. event 函数的其他参数

>   event 函数的后三个参数分别为 x, y, st. st 我们在 render 函数就见过了, 所以这里就不赘述, x, y 参数为以当前组件左上角为原点的事件的相对坐标
>
>   ( 贴出代码 )
>
>   知道这两个参数后我们就可以实现一个简单的跟踪鼠标的组件, 原理就是根据相对坐标来更新图像的更新位置, 让我们看看运行效果吧

### d. 如何阻止事件传播到其他组件

>   在上面 b 小结的代码里面, 我们实现了一个点击效果, 但是我们不难发现, 这个效果并不会阻止鼠标点击其他的组件
>
>   ( 代码和运行效果 )
>
>   例如我们这里将我们的组件遮挡住半个按钮, 然后点击这个按钮, 我们可以发现被遮盖的按钮仍然可以被点击得到, 这是因为我们的组件并没有将这个事件拦截下来, 而是由他传递到了其他组件里, 这个时候我们需要用到一行代码:  `raise renpy.display.core.IgnoreEvent()`, 这串代码可以抛出一个异常, 这个异常可以阻止事件传递到其他组件里
>
>   ( 代码 )
>
>   下面这里, 我定义了一个判断鼠标是否在区域内按下的组件, 假如鼠标在这个组件里按下/抬起, 那么这个组件会接收这个事件来改变自身的状态, 来看看运行效果吧
>
>   ...
>
>   现在我们可以看到被遮挡的按钮不会被触发了

### ending?

>   本期我们学习了该如何让组件接收用户交互事件, 下一期我会介绍该如何制作一个布局组件

---

##  Stage 4. 实现一个实用的底边栏

>   在上文里我们已经介绍过生成可视化组件的基础方法, 在这节里我们将尝试实现对多个子组件进行管理, 也就是一个布局方式, 而最简单的布局方式就是横向排版布局, 底边栏就是一个很好的例子

### a. 最基础的实现方式

>   在这里, 我们定义一个底边栏类, 然后使用一个 `item_spacing` 参数来控死子组件的间隔
>
>   ( 贴出代码解说然后运行 )

### b. 按照子组件的实际大小布局组件

>   在上面的代码里, 每个组件的坐标都是通过 `spacing` 参数进行控制的, 并不会根据组件的大小自动调整, 这里我们就需要通过某种方法来获取子组件的大小
>
>   我们现在都知道 `render` 函数会传入 `width, height` 参数, 但有时候, 我们尝试获取子组件的 `Render` 时传入的 `width, height` 参数和实际获取到的 `Render` 大小并不匹配, 例如 `Text` 对象
>
>   ( 贴出代码和运行结果 )
>
>   观察参数, 我们可以发现无论怎么改变传入的 `size`, 实际的 `size` 始终为一个固定值, 有些组件出于布局或者其他的要求会返回与传入值不同的大小. 所以我们创造自己的组件时也可以根据情况, 动态的变更组件 `Render` 的大小, 
>
>   `Render` 类型有一个 `get_size` 方法, 这个方法可以获取到子组件的实际`Render` 的大小, 通过上文, 我们可以在绘制子组件时记录各个子组件的 `size`, 再根据这个 `size` 来放置各个组件
>
>   ( 贴代码, 运行 )
>
>   这样我们就获得了一个类似于 hbox 的布局组件

### c. 子组件无法被正确 redraw 的问题

>   如果我们使用上面的代码时 `menu_item` 的入参是一些使用 `renpy.redraw` 来更新自身画面的组件时, 我们会发现组件他们调用的`renpy.redraw` 居然完全失效了, 只有在父组件更新的时候才会更新画面, 这里就需要介绍一下  renpy.redraw 的机制了
>
>   简单来说, renpy 存在有渲染缓存机制, 这个机制会保存通过 renpy 方法绘制的各个组件在上次绘制的的图像, 在这个图像没有被申请刷新或者被动刷新时, 任何通过 Renpy 方法访问这个组件的渲染对象时都会检测这个组件是否存在缓存, 如果缓存存在就会直接返回这个缓存并更新渲染树. 而我们向系统请求 renpy.redraw 时就是将这个缓存设置为失效, 并试图重新绘制这个组件
>
>   然而, 我前面渲染子组件的方法全都是直接获取组件的 render 函数的返回值, 直接绕过了 renpy 的缓存机制来获取
>
>   ( 贴文档 https://doc.renpy.cn/zh-CN/cdd.html#renpy.render )
>
>   想将图像缓存到 Renpy 的正确方法是 renpy.render() 函数. 我前面一直直接获取组件的 Render 是为了简易一点的将 render 函数的机制演示出来, 然而到现在多组件的情况下就该变通变通了. 使用 renpy.render 函数后你获取子组件的 Render 就不需要重新把所有的子组件按个绘制, 而是直接通过系统获取到这个组件的渲染缓存, 无论是性能上还是别的东西都是很大的提升.

### d. 子组件的布局问题

>   有些时候, 组件是带有些样式特性的, 例如 `ypos`, `xanchor` 等, 如果我们希望处理这些特性, 可以使用 `renpy.Displayable` 类中的方法 `place` 来自动处理这些参数, 此方法会根据组件内的这些特性以及对应的 `Render` 计算出子组件应该在的位置, 此处引用一下源码及其注释
>
>   (引用代码演示)
>
>   那么, 我们可以修改我们的代码, 让它支持组件的相关坐标变换
>
>   (修改代码并演示)

### ending?

>   在本节里, 我们学习了该如何实现一个布局组件, 下一节里, 我会介绍一些奇特的方法, 这些方法可以让你的组件变得美观一些

---

## Stage 5. 颜色切换的文字

>   在上一节课里我们已经学习了该如何实现一个布局组件, 那么这里就要整些花活了
>
>   ( 展示画面 )
>
>   来看看这个组件, 还挺好看的对吧-----这期视频我会教你如何实现这样的一个组件

### a. 如何实现裁剪效果

>   你以为我要拿出 Crop 组件吗? 虽然那个组件也是一个很好的选择, 但是这里我并不打算介绍那个组件, 而是介绍 Render 函数的 subsurface 函数
>
>   ( 贴文档内容 https://doc.renpy.cn/zh-CN/cdd.html#renpy.Render.subsurface )
>
>   这个函数可以根据像素裁剪下 Render 函数的一个区域内的像素, 这个方法的好处 ( 使用GPU渲染的Crop有BUG的噢 ) 以及坏处 ( 极端环境下会卡 ) 是纯 CPU 计算的, 
>
>   那么裁剪效果就很好做了, 我们先定义两个颜色不同的字体, 然后根据动画的进行来裁剪他们的像素渲染
>
>   ( 贴代码运行 )

### b. 给动画使用缓动曲线

>   ( 打开  https://easings.net/zh-cn )
>
>   缓动曲线是一种将值重新映射的函数, 我们可以打开 easings net 网站去看市面上主流的几种动画曲线以及他们的效果, 如果不懂曲线的原理的话可以先照着抄, 等会就会懂了的 ( )
>
>   ( 贴出 https://doc.renpy.cn/zh-CN/transforms.html#warpers)
>
>   Renpy 对常见的缓动曲线做有支持, 我们可以在文档的这个地方查到 easings net 上对应曲线在 renpy 里面的实现名称, 那么让我们回到我们的代码
>
>   ( 转场 )
>
>   现在我们随便选取一个曲线, 并将他作用到我们的组件上
>
>   ( 代码与演示 )

### c. 通过 canvas  绘制简易的图像

>   我们都知道可以通过 renpy.displayable("#fff") 这种形式来绘制一个单色的正方形组件, 但是如果我们希望绘制一些简单的几何图形呢?  
>
>   (文档链接, https://doc.renpy.cn/zh-CN/cdd.html#renpy.Render.canvas)
>
>   在文档里我们可以查到, `Renpy` 保留了 `pygame` 中 `draw` 模块的功能, 此功能可以帮助我们快速画出一些简单的图形, 下面我们举一个简单的例子:
>
>   ( 贴代码, 运行 )
>
>   所以我们现在就可以给我们的组件绘制上动态的背景了

### d.   让动画在鼠标覆盖时触发, 离开时恢复

>   结合 event 的知识, 我们可以很快的把这个效果做出来, 但是我这里想提的是动画里面常见的三个问题
>
>   一个是动画轴 0~1 映射
>
>   一个是时间轴不重置导致超限
>
>   一个是界面刷新动画中断

---

## Stage 6: 使用注册语句快速调用组件

>   在前面的内容里, 我们已经可以很容易的编写出自己的可视化组件了, 但我们在调用时会特别麻烦, 如果能直接用 renpy 的语法来调用组件的话该多好啊! 这就是本节的内容

### a. 调用组件的其他两种方式

>   1.   show 语句
>
>        >   show 语句可以将一个 define 的组件直接显示到演出脚本上, 例如:
>
>   2.   screen 语句
>
>   >   screen 可以将一个被注册过 SL2 语句的可视化组件以 screen 语法添加到屏幕上, 也就是平常看到的这些 button, frame 什么的. 如何注册可视化组件的课题我们后面再聊, 知道有这个方法先吧

### b.  什么是注册语句

>   官网的文档链接: https://doc.renpy.cn/zh-CN/screen_python.html#creator-defined-sl
>
>   简单来说就是我们可以通过这个函数来将我们自己的可视化组件注册为 `Renpy` 脚本可以识别的关键字, 就像 button, text 那样, 我认为官网的文档写的足够健全了, 请浏览完官网文档的内容再看下面的内容吧 ( 决不是偷懒, 是我自己的表达能力实在是没官网的好 )

### c. 接收子组件的注册语句

>   这个是文档上没写有的, 所以值得一说:
>
>   有时候我们希望当前组件可以容纳其他组件, 作为一个布局容器来使用, 我翻遍文档都没有找到这个内容, 于是拜访了源码后我得出了一个结论: 以 `renpy.displayable.layout.Container` 为基础来编写, 可以将此组件视为布局组件的基型, 如果不想要继承该组件的话, 你的组件里必须包含两个方法: `add` 和 `remove`, 这两个方法用于添加及减少子组件, 例如我们改造一下上面的 `ShakeText`
>
>   ( 展示代码和运行效果 )

### d. 参考项目---按下就改变图像的  button

>   在我的项目里, press_button

### e. 参考项目---分割线 UI 布局

>   在我的项目里, split_layout