# 小白都能看懂的 Renpy CDD 教程 ( 视频稿子 )

---

## Opening

>   大家好, 我是 Koji. 在我休学的一年里, 我研究并编写了一些 CDD, 感受到了这个系统的强大
>
>   用 Renpy 中文文档的话来说
>
>   最复杂也最强大，能够定制Ren’Py表现效果的方式，就是使用创作者定义的可视组件
>
>   因此, 我想把自己这段时间里学到的东西以教程的形式记录下来
>
>   供自己留念, 也供大家参考
>
>   在本系列教程里, 我会从代码出发, 用概念辅助来逐步教大家编写 CDD
>
>   带 * 号的是为了保证内容编排顺序, 但是内容不必须或理解难度过高的原因, 可以选择性跳过的内容

## Stage 1 可视化组件相关概念

>   fix:
>
>   重新录制打字画面
>
>   重新录制声音
>
>   screen 名更改为 screen stage1_add

### 什么是可视组件?

>   ( 显示标题 )
>
>   ( 显示可视化组件页面 )
>
>   首先 什么是可视化组件呢？
>
>   我认为, 可视化组件就是将画面表达出来, 提供用户交互的组件
>
>   例如你现在看到的视频 里面有标题栏 有进度条 有全屏按钮
>
>   这些东西都是所谓的可视化组件 

>   ( 显示 rpy 文件 screen )
>
>   在 Renpy 里面, 我们都知道编写交互界面使用的是 screen 语句
>
>   ( 显示打了 tip 的 rpy 文件 screen )
>
>   Renpy 预设了不少的可视化组件与相应的语法供 screen 语句使用

>   ( B站搜索 CSS 动画)
>
>   
>
>   然而, 系统提供的可视化组件在一定程度上对于想实现华丽效果的开发者来说是不够用的
>
>   这个时候就需要自定义可视化组件技术了
>
>   ( 对着文档念稿 )
>
>   最复杂也最强大，能够定制Ren’Py表现效果的方式，就是使用创作者定义的可视组件
>
>   一个创作者定义的可视组件允许使用任何pygame事件消息
>
>   其可以渲染其他可视组件，并将其他可视组件放置在界面的任何位置
>
>   
>
>   说人话就是: 你可以完全自定义组件与用户的交互, 组件显示画面等逻辑
>
>   举个例子, renpy 的 button 在鼠标按下时是没有对应的词条来改变组件图像的
>
>   但是你可以自定义一个组件来响应这个事件来更改组件的画面
>
>   甚至于是编写一个新的布局, 一整个游戏
>
>   这些都可以使用 创作者定义的可视组件 来实现

### 系统的可视化组件

>   ( 显示小标题 )
>
>   ( 显示文档界面 https://doc.renpy.cn/zh-CN/displayables.html#image-like-displayables )
>
>   在 Renpy 的文档里我们可以直接查到大量的可视化组件
>
>   然而 有些组件 Renpy 并没有明确的写明在文档里

>   ( 显示 button 搜索结果 )
>
>   例如 我们在 screen 里面使用的 button
>
>   我们只可以查到他在 Renpy 语法下的词条, 它的可视化组件在文档里面是找不到的
>
>   这个时候, 我们就需要自己去看 Renpy 引擎里面组件的源码
>
>   这些源码不仅可以直接调用, 还可以参考学习是很有价值的一手资料
>
>   这里我列举三个我参考组件源码时最常用的文件

>   `renpy/display/displayable.py`
>
>   这个文件里面编写了 Displayable 类
>
>   这个类是所有可视化组件的根类
>
>   里面定义了可视化组件的基础框架和接口
>
>   我们可以查看源码里的注释来理解它对各项接口的解释与说明

>   `renpy/display/behavior.py`
>
>   在这个文件里定义了大量的界面交互组件
>
>   例如: Bar 组件 Button 组件 Timer 组件 Input 组件
>
>   我们既可以以这里面实现的可视化组件为父对象拓展他们的功能
>
>   也可以以他们为参照编写新的实现方式

>   `renpy/display/layout.py`
>
>   这个文件里定义了大量的布局组件
>
>   例如: Container, Null, Fixed, Crop
>
>   其中, Container 是容器组件的根类
>
>   如果你希望编写一个新的容器组件, 你应该以 Container 为参照编写

### 如何显示一个可视化组件

>   ( 显示小标题 )
>
>   ( 显示 VSCode 界面 )
>
>   如何显示一个可视化组件?
>
>   最简单的办法是使用 add 语句
>
>   add 语句在界面上添加一个图像或者其他的可视化组件
>
>   添加时可以选择使用 Transform 特性列表

>   ( 开一个空白工程 )
>
>   那么, 现在我们来试验一下, 打开一个空白的工程
>
>   我们可以看到, 这里是程序的主界面
>
>   我们现在希望往主界面上添加一个文本组件, 上面写着"你好世界"
>
>   现在, 我们就需要使用 Text 可视化组件, 然后用 add 语句将他添加上去

>   现在运行代码
>
>   此时我们可以看见 “你好世界” 已经被添加到屏幕上来了
>
>   此外, 我们可以传入一些 transform 特性来改变组件的位置
>
>   **比如, 我们给这个 add 语句后面加上 xalign 0.5, 让他在布局里居中**
>
>   **刷新界面, 我们可以看到文字在屏幕里居中了**

### * add 语句的本质是?

>   观察这段代码, 我们可以发现这行语句是由
>
>   add + 实例化可视化组件 + transform 特性组成的
>
>   那么, 可不可以让 add 语句直接添加一个提前实例化好的可视化组件呢
>
>   让我们稍微改变一下代码的结构
>
>   先在外面定义了一个叫做 hello_world 的变量
>
>   这个变量存储着一个 Text 可视化组件
>
>   让我们直接把这个组件 add 到屏幕上来
>
>   **刷新界面**
>
>   我们可以看到这个组件依然被正确的添加到上面

>   那么, 这个 add 上来是组件和 hello_world 变量的组件是同一个吗?
>
>   验证这点的话, 我们可以先用 for 语句一次性添加多个 hello_world
>
>   然后将 Text 组件换成可以响应鼠标事件的 TextButton 组件
>
>   填好参数后, 让我们看看运行的效果

>   **我们可以看到, 一个按钮被遮盖的时候, 其他按钮也会显示出被遮盖的效果**
>
>   那么我们可以认为:
>
>   add 语句本质上就是将已经初始化好的可视化组件引用到屏幕上的语句
>
>   也就是这些 "你好世界" 全部都是引用着同一个可视化组件
>
>   都是 hello_world 储存的那个可视化组件
>
>   所以无论哪一个 add 触发了遮盖, 都会触发源组件的更新
>
>   从而导致所有的引用被更新
>
>   总结起来就是: add 语句本质上就是一个可以利用 transform 特性的对其他组件的引用语句

### * 神奇的 as 语句

>   在 Renpy  里, 存在一个不怎么起眼的语句, as 语句
>
>   让我们看看文档里对他的描述:
>
>   UI语句可以使用 `as` 从句，后面带一个变量名，不需要引号。 语句创建的可视组件对象将声明为变量。
>
>   这里举一个小例子
>
>   ```python
>   screen stage1_as:
>       text "aaa" as a
>       $ print(a)
>   ```
>
>   运行代码, 我们可以看到命令行打印出了一个 TextObject
>
>   这个 TextObject 就是 screen 中 text 语句自动生成的的可视组件
>
>   
>
>   总的来说, as 语句是获取 screen 语法下自动生成对象最方便的方法
>
>   在你需要调试用 screen 语句生成的组件的时候, 你会用到它的
>
>   
>
>   而 add 语句添加上的组件, 也可以使用 as 语句来获取
>
>   就像这里:
>
>   ```python
>   default stage1_as_obj = Text("aaa")
>   
>   screen stage_1_as:
>       $ print(f"stage1_as_obj{=}")
>       add stage1_as_obj as a
>       $ print(f"a{=}")
>   ```
>
>   我们可以看到打印出来的都是同一个对象
>
>   
>
>   而我在 "add 语句的本质是" 中所讲的内容, 也与 as 语句获取到的信息一致
>
>   ```python
>   default stage1_as_obj = Text("aaa")
>   
>   screen stage_1_as:
>       $ print(f"stage1_as_obj{=}")
>       add stage1_as_obj as a
>       $ print(f"a{=}")
>       add stage1_as_obj as b
>       $ print(f"b{=}")
>       add stage1_as_obj as c
>       $ print(f"c{=}")
>   ```
>
>   所以这也从侧面印证了那个视频中提到的观点

---

## Stage 2: 编写一个简单的 CDD

### render 方法与 renpy.Render 对象

>   我们在前面提到过, 
>
>   创作者定义的可视组件是通过renpy.Displayable类的子类创建的。创作者定义的可视组件必须重写render方法
>
>   那么, 什么是 render 方法?
>
>   让我们看看文档里对此内容的描述
>
>   ( 对着文档念稿 )
>
>   子类必须重新这个方法，并返回一个 [`renpy.Render`](https://doc.renpy.cn/zh-CN/cdd.html#renpy.Render) 对象。渲染器对象决定了在界面的所有显示效果
>
>   -   width, height
>
>       "这个可视组件的有效区域范围，单位为像素。"
>
>       我对这两个参数的理解是此可视化组件在布局中被分配的大小
>
>   -   st
>
>       一个浮点数，表示显示时间轴，单位为秒。
>
>       可视组件在界面上首次显示的时间点，是显示时间轴的起始点。
>
>   -   at
>
>       一个浮点数，动画时间轴，单位为秒。
>
>       带有同样标签(tag)的图像显示而不是隐藏的时间点，是动画时间轴的起始点。
>
>       (当可视组件不使用标签显示，就与显示显示时间轴相同。)
>
>       st 与 at 的区别, 我这里用一个简单的例子来演示
>
>       理解不了也不要紧, 学完了后面的内容再回来看就会明白了
>
>       ```python
>       image a = A_Displayable() # 注意这里的 A_Displayable 指的是任意一个可视化组件, 本身没有这个类型
>       
>       label start:
>          show a
>          "现在 st 和 at 都从 0 开始计数"
>          show a
>          "现在 st 被重置为 0 了 (此可视化组件第一次被显示时的时间戳)\n但 at 仍然是之前的计数 (一个相同名称的可视化组件被第一次显示时的时间戳)"
>          hide a
>          "...."
>          show a
>          "现在 st 和 at 都从 0 开始计数
>       ```
>
>   这里再说说函数的返回值, renpy.Render 对象

>   让我们看看文档里对此内容的描述
>
>   呃....看起来真是让人困惑的描述啊, 我用我自己的话来概括一下这个类吧
>
>   
>
>   `Render` 对象是储存并传递此可视化组件画面与信息的对象
>
>   你可以把它理解为绘画工具里面的一个储存组件画面的图层
>
>   然后我们需要把这个组件的画面丢在这个图层里面, 
>
>   通过父子结构, 把它传递给引擎绘制出来, 很好理解吧?
>
>   
>
>   我们可以通过 `renpy.Render(w, h)`来获取一个透明的 `Render` 对象
>
>   `w, h` 为此对象应该占据的宽高, 但实际上我们在这个图层上的绘制是可以超出 w, h 的
>
>   这两个参数是这个画布应该占据的大小
>
>   
>
>   而 renpy.Render 有一个 blit 方法, 他的作用是
>
>   在这个Render对象中绘制另一个Render对象
>
>   简单来说就是将另一个 Render 上的画面复制到这此 Render 上面来
>
>   从而达到画面传递的作用

### 定义一个可视化组件

>   在了解了 render 方法与 renpy.Render 对象的概念后
>
>   让我们编写一个最简单的
>
>   不显示任何画面, 仅仅是被添加到屏幕上的可视化组件吧
>
>   
>
>   先定义一个类
>
>   让他继承自 renpy.Displayable
>
>   然后是 `__init__` 函数, 然后打上 super 函数
>
>   这里的 super 函数
>
>   再然后是 render 方法, 打好参数后, 让他返回一个以 width, height, 为尺寸的 Render
>
>   然后就是把这个组件 add 到屏幕上了
>
>   
>
>   好的, 运行代码
>
>   如果 Renpy 没有产生任何的报错, 那么恭喜, 你已经写好了一个创作者定义的可视组件了
>
>   
>
>   如果出现了 xxx 报错
>
>   那么是你的类并没有继承自 renpy.Displayable
>
>   如果出现了 xxx 报错
>
>   那么你的 render 方法并没有写好
>
>   如果出现了 xxx 报错
>
>   那么你的 render 方法返回的值并不是一个 Render  对象

### 让组件显示纯色并动起来

>   那么, 让我们修改代码, 让这个可视化组件返回带有图像信息的东西
>
>   
>
>   (展示文档)
>
>   这里介绍一下 renpy.displayable 函数
>
>   这个函数使用入参 *d* 
>
>   *d* 可能是一个可视组件对象或字符串。
>
>   如果是一个字符串，使用常用的规则将其转换为一个可视组件。
>
>   
>
>   现在, 让我们通过 renpy.displayable 函数获取一个可视组件
>
>   使用颜色语法的规则, 可以返回一个单色填充的可视化组件
>
>   将它写在我们的 `__init__` 方法里, 保存到 self 中
>
>   然后在 render 函数里获取这个组件渲染出来的画面
>
>   再将这它渲染到此可视化组件的 Render 对象上
>
>   
>
>   运行代码
>
>   一切无误的话, 就可以看到整个界面都被单色填充了的画面
>
>   
>
>   然后, 让我们限制单色填充组件渲染时传入的 w, h
>
>   运行代码, 我们可以发现纯色区域的大小变成了 w, h 设定的值
>
>   
>
>   让我们调整一下 blit 的 pos 参数, 改成 (200, 100)
>
>   运行代码, 我们可以发现纯色区域被绘制到了
>
>   界面左上角 往右200px, 往下 100px 的位置

>   在了解了简单的调整方法后, 我们现在可以利用这两个方法来调整组件的渲染结果
>
>   以显示出简单的动画效果
>
>   还记得 render 函数的 st 参数吗? 它表示显示时间轴
>
>   那么我们可以依靠时间轴为参照来修改 blit 或 render 的参数
>
>   但是, 让组件动起来的话, 少不了要对组件的画面进行刷新
>
>   这个时候就需要 renpy.redraw 函数了
>
>   ( 文档捧读 )
>
>   经过 when 秒之后重新绘制可视组件 d
>
>   
>
>   那么, 让我们修改一下我们前面编写的组件
>
>   修改让纯色的大小为时间轴的值
>
>   让绘制的位置以时间轴为参数传入三角函数, 做圆周运动
>
>   再使用 renpy.redraw 让组件不停的刷新
>
>   
>
>   运行代码, 我们可以看到组件已经水灵灵的动起来了

### * 探究 render 方法参数的机制

>   现在, 你已经知道 render 方法本身的功能了, 那么, 它的四个参数是什么机制呢?
>
>   首先是 width, height 参数 ( 后面简称 size ). 这里进行一个实验
>
>   在 fixed / hbox 布局下 add 组件
>
>   1.   add 一个组件下 size 的值
>   2.   add 两个组件下 size 的值
>   3.   一个组件被 xysize 限制的情况下 size 的值
>
>   我们可以发现, 在 fixed 布局中, 两个组件在不限制的情况下, size 都是一致的, 为布局中可获得的最大大小
>
>   在限制一个组件时, 并不会对另一个组件获得的 size 产生影响
>
>   然后在 hbox 下, 两个组件在不限制的情况下 add 的一个组件为 size 的大小, 另一个组件的

---

##  Stage 3: 响应用户交互的组件

>   在上文里我们已经讲过了要怎么让可视化输出画面 ,在这里, 我们讲一下要怎么让可视化组件与用户进行交互, 也就是 `CDD` 的 `event` 函数

### a. 什么是 event 函数

>   `event` 函数是用于处理可视化组件事件的函数, 当存在新的事件时会调用这个函数来接收并处理对应的事件, 首先引用一下 `renpy.display.displayable.py` 里 `event` 函数的代码注释
>
>   ( 贴出代码 )
>
>   在这个教程里, 我先不讲 `event` 函数的返回值具有什么意义, 而是重点聚焦在前面的第一个参数 `ev`, 此参数是一个存储了交互信息的参数, 通过解析这个参数我们就可以解析用户进行了哪些行为
>
>   首先, ev 参数有一个 type 参数来判断事件, 这个参数的值为 int, 这些值是以 pygame 的 event  为基础定义的, `Pygame` 里存在一些常量用于确认对应的类型, 比如 `pygame.MOUSEBUTTONDOWN = 1025`
>
>   所以当我们需要判断一个 `ev` 为某个事件时, 就可以用 `ev.type == pygame.xxx(某个常量)` 来判断当前 `ev` 是否为某个事件, 比如 `ev.type == pygame.MOUSEBUTTONDOWN`就是判断当前事件是否为鼠标按下事件
>
>   ( 贴出代码并运行 )
>
>   而这些事件对应的各个常量命名都各自有自己的规则, 这里贴出 pygame 里面对各个事件产量的命名:
>
>   ( 开网站 )
>
>   此外, renpy 也有自己的事件检测方式: renpy.map_event, 这个函数比起 pygame 里面声明的产量之外还可以检测出 Renpy 自定义的一些 event, 相关介绍也有文档 ( 贴图 ), 假如你希望你的组件相应这些交互事件, 那可以考虑用这个来代替 pygame 的那套
>
>   然后, `ev` 中包含有次事件对应的参数, 这个不难理解, 我们可以用 `ev.__dict__` 把 `ev` 的属性打印出来, 就比如 `MOUSEBUTTONDOWN` 事件:
>
>   ( 贴出代码和运行输出 )
>
>   在这里我们可以通过 `button` 参数来获取此 `MOUSEBUTTONDOWN` 事件中鼠标按下的按钮为哪一个
>
>   注意, 不同的 `ev` 甚至是同个 `type` 的 `ev` 都会有不一样的属性 (例如滚轮滑动, 它的 `type` 也是 `MOUSEBUTTONDOWN`, 但参数却有所不同), 所以在使用 ev 参数的时候还请多多注意

### b. 实现相应用户点击

>   那么, 在了解完上面的概念后, 我们就可以很轻松的编写出一个响应用户鼠标事件的组件了
>
>   (贴出代码和 VS Code)
>
>   这里我定义了一个组件, 这个组件会在鼠标按下时立即切换图片, 让我们看看运行结果吧

### c. event 函数的其他参数

>   event 函数的后三个参数分别为 x, y, st. st 我们在 render 函数就见过了, 所以这里就不赘述, x, y 参数为以当前组件左上角为原点的事件的相对坐标
>
>   ( 贴出代码 )
>
>   知道这两个参数后我们就可以实现一个简单的跟踪鼠标的组件, 原理就是根据相对坐标来更新图像的更新位置, 让我们看看运行效果吧

### d. 如何阻止事件传播到其他组件

>   在上面 b 小结的代码里面, 我们实现了一个点击效果, 但是我们不难发现, 这个效果并不会阻止鼠标点击其他的组件
>
>   ( 代码和运行效果 )
>
>   例如我们这里将我们的组件遮挡住半个按钮, 然后点击这个按钮, 我们可以发现被遮盖的按钮仍然可以被点击得到, 这是因为我们的组件并没有将这个事件拦截下来, 而是由他传递到了其他组件里, 这个时候我们需要用到一行代码:  `raise renpy.display.core.IgnoreEvent()`, 这串代码可以抛出一个异常, 这个异常可以阻止事件传递到其他组件里
>
>   ( 代码 )
>
>   下面这里, 我定义了一个判断鼠标是否在区域内按下的组件, 假如鼠标在这个组件里按下/抬起, 那么这个组件会接收这个事件来改变自身的状态, 来看看运行效果吧
>
>   ...
>
>   现在我们可以看到被遮挡的按钮不会被触发了

### ending?

>   本期我们学习了该如何让组件接收用户交互事件, 下一期我会介绍该如何制作一个布局组件

---

##  Stage 4. 实现一个实用的底边栏

>   在上文里我们已经介绍过生成可视化组件的基础方法, 在这节里我们将尝试实现对多个子组件进行管理, 也就是一个布局方式, 而最简单的布局方式就是横向排版布局, 底边栏就是一个很好的例子

### a. 最基础的实现方式

>   在这里, 我们定义一个底边栏类, 然后使用一个 `item_spacing` 参数来控死子组件的间隔
>
>   ( 贴出代码解说然后运行 )

### b. 按照子组件的实际大小布局组件

>   在上面的代码里, 每个组件的坐标都是通过 `spacing` 参数进行控制的, 并不会根据组件的大小自动调整, 这里我们就需要通过某种方法来获取子组件的大小
>
>   我们现在都知道 `render` 函数会传入 `width, height` 参数, 但有时候, 我们尝试获取子组件的 `Render` 时传入的 `width, height` 参数和实际获取到的 `Render` 大小并不匹配, 例如 `Text` 对象
>
>   ( 贴出代码和运行结果 )
>
>   观察参数, 我们可以发现无论怎么改变传入的 `size`, 实际的 `size` 始终为一个固定值, 有些组件出于布局或者其他的要求会返回与传入值不同的大小. 所以我们创造自己的组件时也可以根据情况, 动态的变更组件 `Render` 的大小, 
>
>   `Render` 类型有一个 `get_size` 方法, 这个方法可以获取到子组件的实际`Render` 的大小, 通过上文, 我们可以在绘制子组件时记录各个子组件的 `size`, 再根据这个 `size` 来放置各个组件
>
>   ( 贴代码, 运行 )
>
>   这样我们就获得了一个类似于 hbox 的布局组件

### c. 子组件无法被正确 redraw 的问题

>   如果我们使用上面的代码时 `menu_item` 的入参是一些使用 `renpy.redraw` 来更新自身画面的组件时, 我们会发现组件他们调用的`renpy.redraw` 居然完全失效了, 只有在父组件更新的时候才会更新画面, 这里就需要介绍一下  renpy.redraw 的机制了
>
>   简单来说, renpy 存在有渲染缓存机制, 这个机制会保存通过 renpy 方法绘制的各个组件在上次绘制的的图像, 在这个图像没有被申请刷新或者被动刷新时, 任何通过 Renpy 方法访问这个组件的渲染对象时都会检测这个组件是否存在缓存, 如果缓存存在就会直接返回这个缓存并更新渲染树. 而我们向系统请求 renpy.redraw 时就是将这个缓存设置为失效, 并试图重新绘制这个组件
>
>   然而, 我前面渲染子组件的方法全都是直接获取组件的 render 函数的返回值, 直接绕过了 renpy 的缓存机制来获取
>
>   ( 贴文档 https://doc.renpy.cn/zh-CN/cdd.html#renpy.render )
>
>   想将图像缓存到 Renpy 的正确方法是 renpy.render() 函数. 我前面一直直接获取组件的 Render 是为了简易一点的将 render 函数的机制演示出来, 然而到现在多组件的情况下就该变通变通了. 使用 renpy.render 函数后你获取子组件的 Render 就不需要重新把所有的子组件按个绘制, 而是直接通过系统获取到这个组件的渲染缓存, 无论是性能上还是别的东西都是很大的提升.

### d. 子组件的布局问题

>   有些时候, 组件是带有些样式特性的, 例如 `ypos`, `xanchor` 等, 如果我们希望处理这些特性, 可以使用 `renpy.Displayable` 类中的方法 `place` 来自动处理这些参数, 此方法会根据组件内的这些特性以及对应的 `Render` 计算出子组件应该在的位置, 此处引用一下源码及其注释
>
>   (引用代码演示)
>
>   那么, 我们可以修改我们的代码, 让它支持组件的相关坐标变换
>
>   (修改代码并演示)

### ending?

>   在本节里, 我们学习了该如何实现一个布局组件, 下一节里, 我会介绍一些奇特的方法, 这些方法可以让你的组件变得美观一些

---

## Stage 5. 颜色切换的文字

>   在上一节课里我们已经学习了该如何实现一个布局组件, 那么这里就要整些花活了
>
>   ( 展示画面 )
>
>   来看看这个组件, 还挺好看的对吧-----这期视频我会教你如何实现这样的一个组件

### a. 如何实现裁剪效果

>   你以为我要拿出 Crop 组件吗? 虽然那个组件也是一个很好的选择, 但是这里我并不打算介绍那个组件, 而是介绍 Render 函数的 subsurface 函数
>
>   ( 贴文档内容 https://doc.renpy.cn/zh-CN/cdd.html#renpy.Render.subsurface )
>
>   这个函数可以根据像素裁剪下 Render 函数的一个区域内的像素, 这个方法的好处 ( 使用GPU渲染的Crop有BUG的噢 ) 以及坏处 ( 极端环境下会卡 ) 是纯 CPU 计算的, 
>
>   那么裁剪效果就很好做了, 我们先定义两个颜色不同的字体, 然后根据动画的进行来裁剪他们的像素渲染
>
>   ( 贴代码运行 )

### b. 给动画使用缓动曲线

>   ( 打开  https://easings.net/zh-cn )
>
>   缓动曲线是一种将值重新映射的函数, 我们可以打开 easings net 网站去看市面上主流的几种动画曲线以及他们的效果, 如果不懂曲线的原理的话可以先照着抄, 等会就会懂了的 ( )
>
>   ( 贴出 https://doc.renpy.cn/zh-CN/transforms.html#warpers)
>
>   Renpy 对常见的缓动曲线做有支持, 我们可以在文档的这个地方查到 easings net 上对应曲线在 renpy 里面的实现名称, 那么让我们回到我们的代码
>
>   ( 转场 )
>
>   现在我们随便选取一个曲线, 并将他作用到我们的组件上
>
>   ( 代码与演示 )

### c. 通过 canvas  绘制简易的图像

>   我们都知道可以通过 renpy.displayable("#fff") 这种形式来绘制一个单色的正方形组件, 但是如果我们希望绘制一些简单的几何图形呢?  
>
>   (文档链接, https://doc.renpy.cn/zh-CN/cdd.html#renpy.Render.canvas)
>
>   在文档里我们可以查到, `Renpy` 保留了 `pygame` 中 `draw` 模块的功能, 此功能可以帮助我们快速画出一些简单的图形, 下面我们举一个简单的例子:
>
>   ( 贴代码, 运行 )
>
>   所以我们现在就可以给我们的组件绘制上动态的背景了

### d.   让动画在鼠标覆盖时触发, 离开时恢复

>   结合 event 的知识, 我们可以很快的把这个效果做出来, 但是我这里想提的是动画里面常见的三个问题
>
>   一个是动画轴 0~1 映射
>
>   一个是时间轴不重置导致超限
>
>   一个是界面刷新动画中断

---

## Stage 6: 使用注册语句快速调用组件

>   在前面的内容里, 我们已经可以很容易的编写出自己的可视化组件了, 但我们在调用时会特别麻烦, 如果能直接用 renpy 的语法来调用组件的话该多好啊! 这就是本节的内容

### a. 调用组件的其他两种方式

>   1.   show 语句
>
>        >   show 语句可以将一个 define 的组件直接显示到演出脚本上, 例如:
>
>   2.   screen 语句
>
>   >   screen 可以将一个被注册过 SL2 语句的可视化组件以 screen 语法添加到屏幕上, 也就是平常看到的这些 button, frame 什么的. 如何注册可视化组件的课题我们后面再聊, 知道有这个方法先吧

### b.  什么是注册语句

>   官网的文档链接: https://doc.renpy.cn/zh-CN/screen_python.html#creator-defined-sl
>
>   简单来说就是我们可以通过这个函数来将我们自己的可视化组件注册为 `Renpy` 脚本可以识别的关键字, 就像 button, text 那样, 我认为官网的文档写的足够健全了, 请浏览完官网文档的内容再看下面的内容吧 ( 决不是偷懒, 是我自己的表达能力实在是没官网的好 )

### c. 接收子组件的注册语句

>   这个是文档上没写有的, 所以值得一说:
>
>   有时候我们希望当前组件可以容纳其他组件, 作为一个布局容器来使用, 我翻遍文档都没有找到这个内容, 于是拜访了源码后我得出了一个结论: 以 `renpy.displayable.layout.Container` 为基础来编写, 可以将此组件视为布局组件的基型, 如果不想要继承该组件的话, 你的组件里必须包含两个方法: `add` 和 `remove`, 这两个方法用于添加及减少子组件, 例如我们改造一下上面的 `ShakeText`
>
>   ( 展示代码和运行效果 )

### d. 参考项目---按下就改变图像的  button

>   在我的项目里, press_button

### e. 参考项目---分割线 UI 布局

>   在我的项目里, split_layout